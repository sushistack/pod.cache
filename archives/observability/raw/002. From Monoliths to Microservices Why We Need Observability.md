# 002. 🚀 001. 모놀리식에서 마이크로서비스로- 옵저버빌리티의 여정 시작

## 요약
본 아티클은 애플리케이션 아키텍처의 진화 과정을 통해 옵저버빌리티의 필요성을 탐구합니다. 모놀리식 아키텍처의 한계를 살펴보고, 마이크로서비스 아키텍처로의 전환이 DevOps와 CI/CD에 미치는 영향을 분석합니다. 마지막으로, 마이크로서비스 환경에서의 빈번한 배포와 복잡성 증가가 옵저버빌리티의 중요성을 어떻게 부각시키는지 설명합니다.

## 서론
현대의 소프트웨어 개발은 끊임없이 변화하고 발전하고 있습니다. 빠르고 효율적인 개발 및 배포를 위한 다양한 아키텍처와 방법론이 등장했으며, 이러한 변화 속에서 애플리케이션의 상태를 정확히 파악하고 문제를 신속하게 해결하는 능력, 즉 '옵저버빌리티(Observability)'의 중요성이 더욱 커지고 있습니다. 본 아티클에서는 애플리케이션 아키텍처의 진화 과정을 따라가며 옵저버빌리티의 근본적인 필요성을 이해하고, 복잡성이 증가하는 현대 시스템에서 어떻게 효과적으로 옵저버빌리티를 확보할 수 있는지 살펴보겠습니다.

## 본론

### 1. 모놀리식 아키텍처: 단일체 안의 세상
과거 웹 애플리케이션은 대부분 **모놀리식 아키텍처(Monolithic Architecture)** 로 구축되었습니다. 모놀리식 아키텍처에서는 모든 서비스, 예를 들어 사용자 등록, 결제, 장바구니 기능 등이 하나의 큰 코드베이스에 함께 포함됩니다. 사용자 인터페이스(UI)에 사용되는 JavaScript, CSS, HTML 파일과 백엔드 비즈니스 로직이 뒤섞여 있으며, 이 모든 것은 하나의 거대한 데이터베이스에 의존합니다.

#### 모놀리식 아키텍처의 한계
이러한 구조의 가장 큰 단점은 **수정 사항을 배포할 때 전체 애플리케이션을 재배포해야 한다는 것** 입니다. 이는 개발 속도를 늦추고, 점진적인 개선을 어렵게 만듭니다. 여러 개발자가 동시에 애플리케이션의 여러 부분에서 작업하기보다는, 한 번에 하나의 코드 조각에만 집중해야 했습니다.

```
+-----------------------+
|      Monolithic App   |
|-----------------------|
| - UI (HTML, CSS, JS)  |
| - Business Logic      |
| - Payment Service     |
| - User Registration   |
| - Shopping Cart       |
+-----------------------+
       |
       v
+-----------------------+
|      Single Database  |
+-----------------------+
```

### 2. 마이크로서비스 아키텍처: 작게 나누어 효율적으로
시간이 지남에 따라 우리는 **마이크로서비스 아키텍처(Microservices Architecture)** 라는 새로운 패러다임에 도달했습니다. 마이크로서비스 아키텍처에서는 거대한 단일 애플리케이션을 독립적인 여러 서비스로 분해합니다. 각 서비스는 자체 데이터베이스나 저장소를 가지며, 사용자 인터페이스 역시 서비스와 분리됩니다.

#### 마이크로서비스 아키텍처의 장점
이 아키텍처의 주요 이점은 **전체 애플리케이션을 재배포하지 않고도 작은 변경 사항을 프로덕션 환경에 배포할 수 있다는 것** 입니다. 또한, 각 팀이 독립적으로 여러 서비스를 동시에 개선할 수 있어 개발 효율성이 크게 향상됩니다.

```
+----------+   +----------+   +----------+
| Service A|---| Service B|---| Service C|
+----------+   +----------+   +----------+
    | Database A | Database B | Database C
```

### 3. DevOps 관점에서 본 아키텍처 변화: 워터폴 vs CI/CD
모놀리식 아키텍처는 **폭포수 방법론(Waterfall Methodology)** 에 비유될 수 있습니다. 소프트웨어가 완전히 구축되기 전까지는 배포가 불가능하며, 요구사항 수집, 분석, 설계, 코딩, 테스트, 배포 등 모든 단계를 순차적으로 거쳐야 합니다.

반면, 마이크로서비스 아키텍처는 **지속적 통합 및 지속적 배포(CI/CD: Continuous Integration/Continuous Delivery)** 와 맥락을 같이 합니다. CI/CD에서는 변경 사항을 계획하고, 빠르게 코딩하며, 빌드, 테스트, 릴리스, 배포를 반복합니다. 이후 품질과 결과물을 측정하고, 이 과정을 짧은 주기로 계속 반복합니다.

#### CI/CD의 주기:
1.  **계획 (Plan)**
2.  **코딩 (Code)**
3.  **빌드 (Build)**
4.  **테스트 (Test)**
5.  **릴리스 (Release)**
6.  **배포 (Deploy)**
7.  **측정 (Monitor/Measure)**

전체 애플리케이션이 설계되고 구축될 때까지 기다리는 대신, 작은 단계로 자주 수행하는 것이 CI/CD의 핵심입니다.

### 4. 옵저버빌리티와 마이크로서비스, CI/CD의 관계
그렇다면 CI/CD 방법론과 마이크로서비스 아키텍처는 옵저버빌리티와 어떤 관련이 있을까요?

*   **서비스의 복잡성 증가:** 마이크로서비스 아키텍처에서는 하나의 거대한 애플리케이션이 아닌, 수많은 작은 애플리케이션과 상호작용합니다. 서비스의 수가 많아질수록 문제가 발생하거나 애플리케이션이 중단될 확률이 높아집니다.
*   **서비스 간 통신 실패 가능성:** 이러한 작은 서비스들은 API 호출이나 메시지 전송을 통해 서로 통신하는데, 이 과정에서 **서비스 간 통신 실패(Intra-service communication failure)** 의 가능성이 높아집니다.
*   **보안 취약점 증가:** 더 많은 작은 애플리케이션은 공격 표면(Surface of attack)을 넓혀 보안 위협에 더 취약하게 만들 수 있습니다.
*   **잦은 배포로 인한 위험:** CI/CD 방식은 변경 사항을 자주 배포합니다. 매번의 배포는 시스템에 변화를 가져오므로, **시스템을 중단시킬 위험** 을 내포하고 있습니다.

따라서, 이러한 환경에서는 전체 시스템을 **더욱 적극적으로 모니터링하고 관찰(Observing)** 하려는 노력이 필요하며, 이것이 바로 옵저버빌리티의 중요성이 강조되는 이유입니다.

## 결론
모놀리식 아키텍처에서 마이크로서비스 아키텍처로의 전환은 개발 및 배포의 민첩성을 크게 향상시켰습니다. 그러나 이러한 변화는 필연적으로 시스템의 복잡성을 증가시키고, 서비스 간의 상호작용을 복잡하게 만들며, 잦은 배포로 인한 잠재적 위험을 동반합니다. 이러한 환경에서 애플리케이션의 성능을 보장하고, 장애 발생 시 신속하게 원인을 파악하며, 시스템의 안정성을 유지하기 위해서는 강력한 옵저버빌리티 전략이 필수적입니다. 다음 섹션에서는 이러한 옵저버빌리티의 핵심 구성 요소들에 대해 더 깊이 알아보겠습니다.