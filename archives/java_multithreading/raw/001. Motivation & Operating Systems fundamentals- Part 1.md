# 001. 🚀 왜 멀티스레딩인가 반응성과 성능의 비밀

멀티스레딩은 애플리케이션의 반응성(Responsiveness)과 성능(Performance)을 획기적으로 향상시키는 핵심 전략입니다.
단일 코어에서는 동시성(Concurrency)을, 다중 코어에서는 병렬성(Parallelism)을 통해 효율적인 작업을 가능하게 합니다.
본 글에서는 멀티스레딩의 필요성과 함께 운영체제 관점에서 프로세스 및 스레드의 기본 개념을 소개합니다.

---

## 서론

우리가 일상에서 사용하는 수많은 애플리케이션 중, 응답이 느리거나 한 번에 여러 작업을 처리하지 못해 불편함을 겪었던 경험이 있을 것입니다. 고객 서비스의 긴 대기 시간, 메시지 전송 후 답장을 기다리는 지루함, 결제 버튼 클릭 후 아무런 반응이 없는 답답함 등은 모두 비효율적인 애플리케이션이 초래하는 좋지 않은 사용자 경험의 대표적인 예시입니다.

이러한 문제들을 해결하고 사용자에게 만족스러운 경험을 제공하기 위해 개발자들은 "멀티스레딩(Multithreading)"이라는 강력한 도구를 활용합니다. 멀티스레딩은 애플리케이션이 동시에 여러 작업을 처리할 수 있도록 하여, 오늘날의 복잡하고 요구사항이 많은 시스템에서 필수적인 기술로 자리 잡았습니다. 이 글에서는 멀티스레딩이 왜 필요한지, 그리고 이를 이해하기 위한 운영체제의 기본 개념인 프로세스와 스레드에 대해 자세히 알아보겠습니다.

## 본론

### 멀티스레딩, 왜 필요할까요?

멀티스레딩을 도입해야 하는 주요 동기는 크게 두 가지, 바로 '반응성(Responsiveness)'과 '성능(Performance)' 향상입니다.

#### 1. 향상된 반응성 (Responsiveness)

애플리케이션의 반응성은 사용자가 특정 작업을 수행했을 때 얼마나 빠르고 매끄럽게 피드백을 받을 수 있는지에 대한 척도입니다. 단일 스레드 애플리케이션에서는 한 번에 하나의 작업만 처리할 수 있기 때문에, 시간이 오래 걸리는 작업이 발생하면 다른 모든 작업이 멈추게 됩니다.

예를 들어, 수천 명의 사용자를 대상으로 하는 온라인 쇼핑몰 웹 애플리케이션을 생각해 봅시다. 만약 한 사용자가 여러 개의 상품을 한 번에 대량 구매하여 데이터베이스에 긴 시간이 소요되는 작업을 요청했다고 가정해 봅시다. 이 경우, 단일 스레드 환경이라면 해당 작업이 완료될 때까지 다른 사용자의 모든 요청은 처리되지 않고 대기해야 합니다. 이는 사용자의 불만을 초래하고, 결국 고객 이탈로 이어질 수 있습니다.

**단일 스레드와 멀티스레드의 반응성 비교**

| 시나리오                  | 단일 스레드 (Single-Threaded)                                  | 멀티스레드 (Multi-Threaded)                                      |
| :------------------------ | :------------------------------------------------------------- | :--------------------------------------------------------------- |
| 웹 스토어 대규모 구매 처리 | 첫 번째 사용자의 구매가 완료될 때까지 다른 사용자 대기         | 각 사용자 요청을 별도 스레드에서 처리, 동시 응답 가능          |
| UI 앱 (영화 플레이어)    | 비디오 렌더링 중 마우스 클릭 등 UI 반응 지연                 | 비디오/오디오 처리, UI 이벤트 처리를 각 스레드에서 분리, 즉각 반응 |

멀티스레딩을 사용하면 각 사용자 요청을 별도의 스레드에서 처리하여, 여러 사용자의 요청에 동시에 응답할 수 있습니다. 특히 사용자 인터페이스(UI)를 가진 애플리케이션에서 반응성은 매우 중요합니다. 영화 플레이어 애플리케이션의 경우, 비디오와 오디오를 재생하면서 동시에 사용자의 마우스 클릭이나 키보드 입력에 즉각적으로 반응해야 합니다. 이러한 복합적인 요구사항은 각 작업을 다른 스레드에 할당함으로써 효율적으로 달성할 수 있습니다.

여기서 핵심적인 개념은 **동시성(Concurrency)**입니다. 단일 CPU 코어 환경에서도 운영체제는 여러 스레드를 빠르게 전환하며 실행(Context Switching)함으로써, 마치 모든 작업이 동시에 진행되는 것처럼 보이게 하는 환상을 만들어냅니다. 이를 통해 단일 코어에서도 높은 반응성을 가진 애플리케이션을 개발할 수 있습니다.

#### 2. 극대화된 성능 (Performance)

멀티스레딩의 두 번째 주요 이점은 성능 향상입니다. 현대의 대부분의 CPU는 여러 개의 코어(Core)를 가지고 있습니다. 멀티스레딩을 활용하면 이러한 다중 코어를 완벽하게 사용하여 여러 작업을 **병렬적(Parallel)**으로 실행할 수 있습니다. 동시성(Concurrency)이 단일 코어에서 여러 작업을 동시에 하는 '착시'라면, 병렬성(Parallelism)은 다중 코어에서 여러 작업을 '진짜로' 동시에 실행하는 것을 의미합니다.

**성능 향상의 주요 이점:**

*   **복잡한 작업의 빠른 완료:** 시간이 오래 걸리는 복잡한 작업을 여러 부분으로 나누어 각 부분을 다른 스레드에서 동시에 처리함으로써 전체 작업 시간을 획기적으로 단축할 수 있습니다.
*   **처리량 증가:** 동일한 시간 내에 더 많은 작업을 완료하여 시스템의 전반적인 처리량(Throughput)을 높일 수 있습니다.
*   **인프라 비용 절감:** 대규모 서비스를 운영하는 경우, 멀티스레딩을 통해 각 머신이 더 많은 부하를 처리할 수 있게 되어 필요한 서버의 수를 줄이고, 결과적으로 인프라 구축 및 유지보수 비용을 절감할 수 있습니다.

요약하자면, 멀티스레딩은 애플리케이션이 사용자에게 즉각적인 피드백을 제공하고(반응성), 주어진 시간 안에 더 많은 작업을 더 빠르게 처리하도록(성능) 돕는 필수적인 기술입니다.

### 프로세스와 스레드: 운영체제 기본 개념

멀티스레딩을 깊이 이해하기 위해서는 운영체제(Operating System, OS)의 기본적인 개념인 프로세스(Process)와 스레드(Thread)를 알아야 합니다.

#### 1. 운영체제의 역할과 프로세스

컴퓨터의 전원을 켜면 가장 먼저 운영체제(OS)가 디스크에서 메모리로 로드됩니다. OS는 하드웨어와 CPU에 대한 추상화 계층을 제공하여 개발자가 하드웨어를 직접 제어하지 않고도 애플리케이션을 개발하고 실행할 수 있도록 돕습니다.

우리가 사용하는 텍스트 에디터, 웹 브라우저, 음악 플레이어와 같은 모든 애플리케이션은 디스크에 파일 형태로 존재합니다. 사용자가 특정 애플리케이션을 실행하면, 운영체제는 해당 프로그램 파일을 디스크에서 읽어 메모리에 로드하고, 이 애플리케이션의 실행 인스턴스를 생성합니다. 이 실행 인스턴스를 바로 **프로세스(Process)**라고 부릅니다. 프로세스는 때때로 애플리케이션의 "컨텍스트(Context)"라고도 불립니다.

각 프로세스는 시스템에서 실행되는 다른 모든 프로세스로부터 완전히 **격리(Isolated)**되어 있습니다. 이는 한 프로세스의 오류가 다른 프로세스에 영향을 미치지 않도록 보호하는 중요한 메커니즘입니다.

**프로세스가 포함하는 주요 요소:**

```
[ 프로세스 구성 요소 ]
- 메타데이터 (Metadata): 프로세스 ID(PID), 열린 파일 목록 등
- 코드 (Code): 실행될 프로그램 명령어
- 힙 (Heap): 동적으로 할당되는 데이터 영역
- 스택 (Stack): 지역 변수 및 함수 호출 정보 (최소 하나의 스레드를 통해 존재)
- 최소 하나의 스레드 (Main Thread): 모든 프로세스는 하나 이상의 스레드를 가짐
```
*참고: 스택은 엄밀히 말하면 스레드의 고유 영역에 속하지만, 프로세스 전체의 메모리 공간 내에 존재합니다. 위 리스트는 프로세스가 관리하는 큰 범주의 요소들을 설명한 것입니다.*

#### 2. 스레드의 구성과 공유 영역

모든 프로세스는 최소한 하나 이상의 스레드를 가집니다. 이 첫 번째 스레드를 **메인 스레드(Main Thread)**라고 합니다. 스레드(Thread)는 프로세스 내에서 실제 코드를 실행하는 흐름의 단위입니다.

멀티스레드 애플리케이션에서는 각 스레드가 고유한 요소를 가지면서도, 프로세스의 일부 리소스를 공유합니다.

**스레드의 고유 요소:**

*   **스택 (Stack):** 지역 변수가 저장되고 함수 호출이 이루어지는 메모리 영역입니다. 각 스레드는 독립적인 함수 호출과 지역 변수를 관리해야 하므로, 자신만의 스택을 가집니다.
*   **명령어 포인터 (Instruction Pointer, Program Counter):** 현재 스레드가 다음에 실행할 명령어의 주소를 가리키는 포인터입니다. 각 스레드는 독립적인 실행 흐름을 가지므로, 고유한 명령어 포인터가 필요합니다.

**스레드가 공유하는 프로세스 요소:**

*   **코드 (Code):** 프로세스 내 모든 스레드는 동일한 프로그램 명령어를 실행합니다.
*   **힙 (Heap):** 동적으로 할당되는 데이터 영역입니다. 스레드 간에 공유되는 전역 변수나 동적으로 할당된 객체들은 힙에 저장되며, 모든 스레드가 접근할 수 있습니다.
*   **파일 (Files):** 프로세스가 열어놓은 파일 디스크립터(File Descriptor)는 모든 스레드에 의해 공유됩니다.

**프로세스 및 스레드의 구성 요소 요약:**

| 구성 요소        | 프로세스 (공유)    | 스레드 (고유)      | 설명                                                    |
| :--------------- | :----------------- | :----------------- | :------------------------------------------------------ |
| **메타데이터**   | ✅                 | ❌                 | PID, 열린 파일 등                                       |
| **코드**         | ✅                 | ❌                 | 프로그램 명령어                                         |
| **힙 (Heap)**    | ✅                 | ❌                 | 동적으로 할당되는 데이터                                |
| **스택 (Stack)** | ❌                 | ✅                 | 지역 변수 및 함수 호출 정보 (각 스레드마다 독립)        |
| **명령어 포인터** | ❌                 | ✅                 | 다음 실행할 명령어의 주소 (각 스레드마다 독립)          |

각 스레드가 자신만의 스택과 명령어 포인터를 가지는 이유는 명확합니다. 각 스레드는 주어진 시점에 다른 함수에서 다른 명령어를 실행하고 있기 때문입니다. 이러한 구조를 통해 멀티스레드는 프로세스 내에서 독립적인 실행 흐름을 유지하면서도, 프로세스의 자원을 효율적으로 공유하며 협력할 수 있습니다.

## 결론

이번 글에서는 멀티스레딩이 현대 애플리케이션 개발에 왜 필수적인지, 그 핵심 동기인 반응성과 성능 향상에 대해 살펴보았습니다. 단일 코어 환경에서의 동시성과 다중 코어 환경에서의 병렬성 개념을 통해 어떻게 이러한 이점들을 얻을 수 있는지도 알아보았습니다.

또한, 멀티스레딩을 이해하기 위한 기초 지식으로서 운영체제가 애플리케이션을 실행하는 방식과 프로세스의 구성 요소들을 설명하고, 더 나아가 프로세스 내에서 실제 실행 단위를 담당하는 스레드가 어떤 고유한 요소와 공유 요소를 가지는지 구체적으로 파악했습니다.

멀티스레드 프로그래밍은 단일 스레드 프로그래밍과는 다른 복잡성을 가지지만, 이를 통해 개발자는 사용자에게 더 빠르고, 더 유연하며, 더 만족스러운 경험을 제공하는 고성능 애플리케이션을 구축할 수 있습니다. 앞으로 이어질 강의에서는 이러한 기본적인 이해를 바탕으로 실제 멀티스레드 애플리케이션을 개발하는 데 필요한 도구와 기술들을 심층적으로 다룰 예정입니다.