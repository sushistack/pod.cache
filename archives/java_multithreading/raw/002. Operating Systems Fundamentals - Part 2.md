# 002. 🚀 운영체제 핵심 파헤치기- 컨텍스트 스위치, 스레드 스케줄링, 그리고 최적의 선택

이 아티클은 운영체제(OS)의 근본적인 메커니즘인 컨텍스트 스위치와 스레드 스케줄링의 원리를 심층적으로 탐구합니다. 과도한 스레드가 시스템 성능에 미치는 영향인 '쓰레싱' 현상을 이해하고, 프로세스와 스레드 간의 효율적인 사용 전략을 제시합니다. 개발자들이 애플리케이션의 성능과 안정성을 최적화하기 위한 핵심 지식을 얻을 수 있도록 돕습니다.

## 서론: 멀티태스킹 시대, 운영체제의 현명한 선택

현대의 컴퓨터 시스템은 동시에 여러 작업을 처리하는 멀티태스킹 환경을 기본으로 합니다. 웹 브라우저를 사용하면서 음악을 듣고, 백그라운드에서는 파일을 다운로드하는 등의 작업이 끊임없이 이루어지죠. 이러한 동시성(Concurrency)을 가능하게 하는 핵심적인 역할은 바로 운영체제(OS)가 담당합니다.

OS는 제한된 CPU 코어 자원 안에서 수많은 프로세스와 스레드를 효율적으로 관리하고 실행해야 합니다. 이 과정에서 발생하는 '컨텍스트 스위치'와 '스레드 스케줄링'은 애플리케이션의 성능과 사용자 경험에 지대한 영향을 미칩니다. 이번 아티클에서는 이러한 OS의 기본 원리를 깊이 이해하고, 나아가 개발자가 언제 스레드를 사용하고 언제 프로세스를 사용하는 것이 유리한지 판단하는 실용적인 가이드라인을 제시합니다.

## 본론: 운영체제의 핵심 메커니즘 이해하기

### 1. 컨텍스트 스위치(Context Switch): 동시성의 숨겨진 비용

우리가 실행하는 애플리케이션의 각 인스턴스는 다른 프로세스와 독립적으로 실행됩니다. 하지만 시스템에는 CPU 코어의 수보다 훨씬 많은 프로세스와 스레드가 존재하기 마련입니다. 각 프로세스는 하나 이상의 스레드를 가질 수 있으며, 이 스레드들은 CPU에서 실행되기 위해 서로 경쟁합니다.

CPU 코어가 아무리 많더라도, 실행 대기 중인 스레드의 수가 훨씬 많으므로, 운영체제는 한 스레드를 실행하다가 중지하고, 다른 스레드를 실행하는 과정을 반복해야 합니다. 이처럼 **한 스레드의 실행을 중단하고 다른 스레드를 실행하기 위해 필요한 상태 정보를 저장하고 복원하는 일련의 과정**을 '컨텍스트 스위치'라고 합니다.

컨텍스트 스위치가 중요한 이유는 결코 '저렴한' 작업이 아니기 때문입니다. 이는 동시성을 확보하기 위해 우리가 지불해야 하는 성능 비용입니다. 인간이 여러 작업을 전환할 때 잠시 집중력을 잃는 시간처럼, OS도 컨텍스트 스위치 과정에서 비생산적인 시간을 소모합니다.

**컨텍스트 스위치의 비용:**

*   **자원 저장 및 복원:** 각 스레드가 CPU에서 실행될 때, 레지스터, CPU 캐시, 커널 메모리 자원 등을 사용합니다. 컨텍스트 스위치가 발생하면, 현재 스레드의 이 모든 상태 정보를 저장하고, 새로 실행될 스레드의 상태 정보를 CPU 및 메모리로 다시 로드해야 합니다.
*   **쓰레싱(Thrashing):** 너무 많은 스레드가 존재할 경우, 운영체제는 실제 작업을 수행하는 시간보다 컨텍스트 스위치에 더 많은 시간을 할애하게 됩니다. 이러한 현상을 '쓰레싱'이라고 하며, 시스템의 전반적인 성능을 저하시키는 주범이 됩니다.

**스레드 vs. 프로세스 컨텍스트 스위치 비용:**

컨텍스트 스위치는 스레드 간에도, 프로세스 간에도 발생할 수 있습니다. 중요한 차이점은 다음과 같습니다.

*   **스레드 내 컨텍스트 스위치:** 동일한 프로세스 내의 두 스레드 간 컨텍스트 스위치는 훨씬 저렴합니다. 스레드들은 프로세스의 많은 자원(메모리 공간 등)을 공유하기 때문에, 저장하고 복원해야 할 정보가 상대적으로 적습니다.
*   **프로세스 간 컨텍스트 스위치:** 서로 다른 프로세스 간의 컨텍스트 스위치는 더 많은 비용이 듭니다. 각 프로세스는 독립적인 메모리 공간과 자원을 가지므로, 전환 시 더 많은 상태 정보를 저장하고 복원해야 합니다.

### 2. 스레드 스케줄링: CPU 시간을 공정하게 분배하는 방법

컨텍스트 스위치를 이해했다면, 이제 운영체제가 언제 어떤 스레드를 실행할지 결정하는 '스레드 스케줄링'에 대해 알아볼 차례입니다.

가상의 시나리오를 통해 스케줄링의 복잡성을 이해해봅시다. 우리가 즐겨 사용하는 텍스트 편집기(UI 스레드, 파일 저장 스레드)와 백그라운드에서 음악을 재생하는 뮤직 플레이어(음악 로딩/재생 스레드, UI 스레드)가 하나의 CPU 코어에서 동시에 실행된다고 가정해봅시다. 총 4개의 스레드가 존재하며, OS는 이 스레드들에게 CPU 시간을 할당해야 합니다.

**초기 스케줄링 방식의 한계:**

운영체제가 스레드를 스케줄링하는 단순한 방식들을 생각해보고, 그 문제점을 파악해봅시다.

1.  **선입선출(First Come, First Serve - FCFS):**
    *   **원리:** 가장 먼저 도착한 스레드를 먼저 실행합니다.
    *   **문제점:** 만약 매우 긴 작업을 수행하는 스레드가 먼저 도착하면, 다른 스레드들은 오랫동안 기다려야 합니다. 이를 '기아(Starvation)' 현상이라고 합니다. 특히 사용자 인터페이스(UI) 스레드가 기아 상태에 빠지면 애플리케이션이 응답하지 않게 되어 사용자 경험을 심각하게 해칩니다.

2.  **최단 작업 우선(Shortest Job First - SJF):**
    *   **원리:** 실행 시간이 가장 짧을 것으로 예상되는 스레드를 먼저 실행합니다.
    *   **문제점:** UI 스레드처럼 짧은 작업이 계속해서 시스템에 들어올 경우, 계산량이 많은 긴 작업 스레드들은 영원히 실행되지 못하고 기아 상태에 빠질 수 있습니다.

**현대 운영체제의 스케줄링 방식: 동적 우선순위와 에포크**

현대 운영체제는 위와 같은 단순한 방식의 단점을 보완하기 위해 훨씬 정교한 스케줄링 알고리즘을 사용합니다. 대부분의 운영체제는 CPU 시간을 '에포크(Epochs)'라는 중간 크기의 조각으로 나눕니다. 각 에포크 동안 운영체제는 각 스레드에 다른 '타임 슬라이스(Time Slice)'를 할당합니다. 모든 스레드가 매 에포크마다 실행되거나 완료되는 것은 아닙니다.

스레드에 할당되는 시간의 양은 **동적 우선순위(Dynamic Priority)**에 의해 결정됩니다.

*   **정적 우선순위(Static Priority):** 개발자가 미리 설정하는 고정된 우선순위입니다.
*   **동적 우선순위(Dynamic Priority):** 운영체제가 매 에포크마다 스레드의 정적 우선순위에 '보너스'를 부여하거나 조정하여 결정합니다.

**동적 우선순위 스케줄링의 목표:**

*   **상호작용성 및 실시간성 보장:** 사용자 인터랙션이 필요한 UI 스레드나 실시간 처리가 필요한 스레드에는 더 높은 우선순위를 부여하여 즉각적인 응답성을 제공합니다.
*   **기아 현상 방지:** 이전 에포크에서 충분한 실행 시간을 얻지 못했거나 완료되지 못한 계산 스레드에는 우선순위를 높여 기아 상태에 빠지는 것을 방지합니다.

이러한 동적이고 유연한 스케줄링 방식을 통해 운영체제는 CPU 시간을 스레드들에게 공정하게 배분하고, 전반적인 시스템 성능과 사용자 경험의 균형을 유지합니다.

### 3. 스레드 vs. 프로세스: 언제 무엇을 선택할 것인가?

이제 마지막으로, 개발자가 멀티태스킹 애플리케이션을 설계할 때 스레드와 프로세스 중 어떤 것을 선택해야 할지에 대한 가이드라인을 제시합니다.

| 특징               | 스레드 (Threads)                                  | 프로세스 (Processes)                                   |
| :----------------- | :------------------------------------------------ | :----------------------------------------------------- |
| **자원 공유**      | 동일 프로세스 내에서 많은 자원(메모리, 파일 핸들 등)을 공유 | 완전히 독립적인 자원(각자 고유한 메모리 공간)을 가짐 |
| **생성/소멸 속도** | 빠름                                              | 느림                                                   |
| **컨텍스트 스위치** | 동일 프로세스 내에서 저렴하고 빠름                | 독립적인 주소 공간으로 인해 비싸고 느림                |
| **통신 방식**      | 공유 메모리를 통한 직접 통신 (lock 필요)          | IPC(Inter-Process Communication) 메커니즘 사용         |
| **격리 및 안정성** | 하나의 스레드 오류가 전체 프로세스에 영향           | 한 프로세스 오류가 다른 프로세스에 영향 미치지 않음    |

**스레드를 사용하는 경우:**

*   **데이터 공유가 필요한 경우:** 여러 작업이 동일한 데이터나 자원(메모리 내 변수, 파일 등)을 빈번하게 공유해야 할 때 스레드가 유리합니다. 공유 메모리를 통해 효율적인 통신이 가능합니다.
*   **생성/소멸 빈번:** 작업의 생성 및 소멸이 잦고, 빠르게 이루어져야 할 때 스레드가 프로세스보다 가볍습니다.
*   **컨텍스트 스위치 오버헤드 최소화:** 동일 프로세스 내 스레드 간 전환은 프로세스 간 전환보다 훨씬 빠르고 저렴합니다.
*   **단일 애플리케이션 내 병렬 처리:** 하나의 애플리케이션 내에서 UI 처리, 백그라운드 작업, 데이터 처리 등 여러 논리적 단위를 병렬로 실행해야 할 때 적합합니다.

**프로세스를 사용하는 경우:**

*   **보안 및 안정성 우선:** 각 작업이 완전히 독립적으로 실행되어야 하며, 한 작업의 실패가 다른 작업에 영향을 미치지 않도록 강력한 격리가 필요할 때 프로세스가 적합합니다.
*   **관련 없는 작업 처리:** 서로 다른 기능이나 목적을 가진 독립적인 애플리케이션을 실행할 때 사용합니다. 예를 들어, 웹 서버와 데이터베이스 서버는 서로 다른 프로세스로 실행됩니다.
*   **자원 격리 필요:** 각 작업이 자신만의 독립적인 메모리 공간과 시스템 자원을 사용해야 할 때 유용합니다.

## 결론: 운영체제 지식으로 더 나은 소프트웨어 개발

이번 아티클에서는 운영체제 심층적인 이해를 돕는 세 가지 핵심 개념인 컨텍스트 스위치, 스레드 스케줄링, 그리고 스레드와 프로세스의 선택 기준에 대해 알아보았습니다.

*   **컨텍스트 스위치**는 동시성을 위한 필수 메커니즘이지만, 그에 따른 성능 비용을 인지하고 과도한 스레드 생성이 '쓰레싱'으로 이어질 수 있음을 이해하는 것이 중요합니다.
*   **스레드 스케줄링**은 운영체제가 동적 우선순위와 에포크 방식을 통해 CPU 시간을 효율적이고 공정하게 분배하여, 애플리케이션의 응답성과 처리율의 균형을 맞추는 복잡한 과정입니다.
*   **스레드와 프로세스의 선택**은 개발하는 애플리케이션의 요구사항(데이터 공유, 안정성, 성능 등)에 따라 신중하게 결정해야 합니다.

이러한 운영체제에 대한 이해는 단순히 이론적인 지식에 그치지 않고, 개발자가 더 견고하고 효율적인 소프트웨어를 설계하고 구현하는 데 필수적인 통찰력을 제공합니다. 다음 프로젝트에서는 오늘 배운 지식을 바탕으로 여러분의 애플리케이션을 더욱 최적화해 보시기 바랍니다.